<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Daily Planner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"
    />
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script
      type="module"
      src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"
    ></script>
    <script
      nomodule
      src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"
    ></script>
    <style>
      ::-webkit-scrollbar {
        width: 8px;
        border-radius: 10px;
      }
      ::-webkit-scrollbar-track {
        background: #1e293b;
      }
      ::-webkit-scrollbar-thumb {
        background: #64748b;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #94a3b8;
      }
      .priority-high {
        border-left-color: #ef4444;
      }
      .priority-medium {
        border-left-color: #f97316;
      }
      .priority-low {
        border-left-color: #22c55e;
      }
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.75);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 1rem;
      }
      .modal-content {
        padding: 1.5rem;
        border-radius: 0.5rem;
        width: 95%;
        max-width: 600px;
        max-height: 90vh;
        overflow-y: auto;
        position: relative;
        background: #1e293b;
      }
      .modal-close-button {
        position: absolute;
        top: 0.75rem;
        right: 0.75rem;
        background: transparent;
        border: none;
        font-size: 1.75rem;
        line-height: 1;
        cursor: pointer;
        padding: 0.25rem;
        color: #94a3b8;
      }
      .flatpickr-calendar {
        background-color: #334155;
        border-color: #4b5563;
        color: #e2e8f0;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.4),
          0 4px 6px -2px rgba(0, 0, 0, 0.35);
        border-radius: 0.375rem;
      }
      .flatpickr-months .flatpickr-month,
      .flatpickr-current-month .flatpickr-monthDropdown-months,
      .flatpickr-current-month input.cur-year {
        color: #e2e8f0;
        font-weight: 500;
      }
      .flatpickr-months .flatpickr-prev-month svg,
      .flatpickr-months .flatpickr-next-month svg {
        fill: #94a3b8;
        width: 16px;
        height: 16px;
      }
      .flatpickr-months .flatpickr-prev-month:hover svg,
      .flatpickr-months .flatpickr-next-month:hover svg {
        fill: #38bdf8;
      }
      .flatpickr-weekday {
        color: #94a3b8;
        font-weight: 500;
      }
      .flatpickr-day {
        color: #cbd5e1;
        border-radius: 0.25rem;
      }
      .flatpickr-day:hover,
      .flatpickr-day:focus {
        background: #475569;
        color: #f1f5f9;
        border-color: transparent;
      }
      .flatpickr-day.selected,
      .flatpickr-day.startRange,
      .flatpickr-day.endRange {
        background: #0ea5e9;
        border-color: #0ea5e9 SSI9;
        color: white;
      }
      .flatpickr-day.today {
        border-color: #f97316;
        color: #f97316;
      }
      .flatpickr-day.today:hover,
      .flatpickr-day.today:focus {
        background: #ea580c;
        border-color: #ea580c;
        color: white;
      }
      .flatpickr-day.flatpickr-disabled,
      .flatpickr-day.flatpickr-disabled:hover {
        color: #4b5563;
        background: transparent;
        cursor: default;
      }
      .flatpickr-input[readonly] {
        cursor: pointer;
      }
      .flatpickr-day.has-tasks {
        font-weight: bold;
        position: relative;
      }
      .flatpickr-day.has-tasks .task-indicator-dot {
        height: 6px;
        width: 6px;
        background-color: #f59e0b;
        border-radius: 50%;
        display: block;
        position: absolute;
        bottom: 3px;
        left: 50%;
        transform: translateX(-50%);
      }
      .flatpickr-day.has-tasks.selected .task-indicator-dot,
      .flatpickr-day.has-tasks.today .task-indicator-dot {
        background-color: #fff;
      }
      .notification {
        position: fixed;
        top: 1.25rem;
        right: 1.25rem;
        padding: 1rem;
        border-radius: 0.5rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05);
        color: white;
        z-index: 2000;
        opacity: 0;
        transform: translateY(-20px);
        transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .notification.show {
        opacity: 1;
        transform: translateY(0);
      }
      .notification-error {
        background-color: #ef4444;
      }
      .notification-success {
        background-color: #22c55e;
      }
      .notification-info {
        background-color: #3b82f6;
      }
      .notification button {
        background: transparent;
        border: none;
        color: white;
        margin-left: 1rem;
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1;
        cursor: pointer;
      }
      .task-description-content {
        white-space: pre-wrap;
        word-break: break-word;
        max-height: 200px;
        overflow-y: auto;
        padding: 0.5rem;
        background-color: #475569;
        border-radius: 0.25rem;
      }
      .task-enter {
        opacity: 0;
        transform: translateY(10px);
      }
      .task-enter-active {
        opacity: 1;
        transform: translateY(0);
        transition: opacity 300ms, transform 300ms;
      }
      .task-exit {
        opacity: 1;
      }
      .task-exit-active {
        opacity: 0;
        transform: translateY(10px);
        transition: opacity 300ms, transform 300ms;
      }
      .progress-bar {
        height: 8px;
        border-radius: 4px;
        background-color: #334155;
        overflow: hidden;
      }
      .progress-bar-fill {
        height: 100%;
        background-color: #0ea5e9;
        transition: width 0.3s ease-in-out;
      }
    </style>
  </head>
  <body
    class="bg-gradient-to-br from-slate-900 to-slate-800 text-slate-100 font-sans antialiased"
  >
    <div id="root"></div>
    <script type="text/babel">
      const { useState, useEffect, useMemo, useCallback, useRef } = React;
      const getTodayDateString = () => {
        const today = new Date();
        const offset = today.getTimezoneOffset() * 60000;
        const localToday = new Date(today.getTime() - offset);
        return localToday.toISOString().split("T")[0];
      };
      const formatDateForDisplay = (dateString) => {
        if (!dateString) return "No Date";
        const date = new Date(dateString + "T00:00:00Z");
        return date.toLocaleDateString(undefined, {
          weekday: "long",
          year: "numeric",
          month: "long",
          day: "numeric",
          timeZone: "UTC",
        });
      };
      const formatShortDate = (dateString) => {
        if (!dateString) return "";
        const date = new Date(dateString + "T00:00:00Z");
        return date.toLocaleDateString(undefined, {
          month: "short",
          day: "numeric",
          timeZone: "UTC",
        });
      };
      const formatTimeForDisplay = (timeString) => {
        if (!timeString) return "";
        const [hours, minutes] = timeString.split(":");
        const date = new Date();
        date.setHours(parseInt(hours), parseInt(minutes));
        return date.toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
          hour12: true,
        });
      };
      function Notification({ message, type, onClose }) {
        if (!message) return null;
        const [show, setShow] = useState(false);
        useEffect(() => {
          if (message) {
            setShow(true);
            const timer = setTimeout(() => {
              setShow(false);
              setTimeout(onClose, 300);
            }, 3000);
            return () => clearTimeout(timer);
          } else {
            setShow(false);
          }
        }, [message, onClose]);
        let typeClasses = "notification-info";
        if (type === "error") typeClasses = "notification-error";
        if (type === "success") typeClasses = "notification-success";
        return (
          <div
            className={`notification ${typeClasses} ${show ? "show" : ""}`}
            role="alert"
          >
            <span>{message}</span>
            <button
              onClick={() => {
                setShow(false);
                setTimeout(onClose, 300);
              }}
              aria-label="Close notification"
            >
              Ã—
            </button>
          </div>
        );
      }
      function ErrorBoundary({ children }) {
        const [hasError, setHasError] = useState(false);
        const handleError = () => {
          setHasError(true);
        };
        if (hasError) {
          return (
            <div className="text-center py-8 text-slate-400">
              <h2 className="text-2xl mb-4">Something went wrong.</h2>
              <p>Please refresh the page or try again later.</p>
            </div>
          );
        }
        return <React.Fragment>{children}</React.Fragment>;
      }
      function App() {
        const [tasks, setTasks] = useState(() => {
          const savedTasks = localStorage.getItem("dailyPlannerTasks_v8");
          try {
            return savedTasks ? JSON.parse(savedTasks) : {};
          } catch (e) {
            console.error("Failed to parse tasks from localStorage", e);
            return {};
          }
        });
        const [selectedDate, setSelectedDate] = useState(getTodayDateString());
        const [filter, setFilter] = useState("all");
        const [sortBy, setSortBy] = useState("time");
        const [categoryFilter, setCategoryFilter] = useState("all");
        const [searchQuery, setSearchQuery] = useState("");
        const [editingTask, setEditingTask] = useState(null);
        const [viewingTaskDetails, setViewingTaskDetails] = useState(null);
        const [showAllTasks, setShowAllTasks] = useState(false);
        const dateInputRef = useRef(null);
        const flatpickrInstanceRef = useRef(null);
        const searchInputRef = useRef(null);
        const [notification, setNotification] = useState({
          message: "",
          type: "",
          key: 0,
        });
        const showAppNotification = (message, type = "info") => {
          setNotification({ message, type, key: Date.now() });
        };
        useEffect(() => {
          localStorage.setItem("dailyPlannerTasks_v8", JSON.stringify(tasks));
          if (flatpickrInstanceRef.current) {
            flatpickrInstanceRef.current.redraw();
          }
        }, [tasks]);
        useEffect(() => {
          if (dateInputRef.current) {
            if (flatpickrInstanceRef.current)
              flatpickrInstanceRef.current.destroy();
            const instance = flatpickr(dateInputRef.current, {
              dateFormat: "Y-m-d",
              defaultDate: selectedDate,
              disableMobile: true,
              allowInput: false,
              onChange: (selectedDatesArr) => {
                if (selectedDatesArr[0]) {
                  const newDate = selectedDatesArr[0]
                    .toISOString()
                    .split("T")[0];
                  setSelectedDate(newDate);
                  if (showAllTasks) setShowAllTasks(false);
                }
              },
              onDayCreate: function (dObj, dStr, fp, dayElem) {
                const dateKey = dayElem.dateObj.toISOString().split("T")[0];
                if (tasks[dateKey] && tasks[dateKey].length > 0) {
                  dayElem.classList.add("has-tasks");
                  const dot = document.createElement("span");
                  dot.className = "task-indicator-dot";
                  dayElem.appendChild(dot);
                }
              },
              onOpen: function (selectedDates, dateStr, instance) {
                instance.set("defaultDate", selectedDate);
                instance.jumpToDate(selectedDate);
                instance.redraw();
              },
            });
            flatpickrInstanceRef.current = instance;
          }
          return () => {
            if (flatpickrInstanceRef.current) {
              flatpickrInstanceRef.current.destroy();
              flatpickrInstanceRef.current = null;
            }
          };
        }, [tasks, selectedDate, showAllTasks]);
        const categories = useMemo(() => {
          const allCategories = new Set(["all"]);
          Object.values(tasks)
            .flat()
            .forEach((task) => {
              if (task.category) allCategories.add(task.category);
            });
          return Array.from(allCategories);
        }, [tasks]);
        const tasksToDisplaySource = useMemo(() => {
          if (showAllTasks) {
            return Object.entries(tasks).flatMap(([date, dateTasks]) =>
              dateTasks.map((task) => ({ ...task, originalDate: date }))
            );
          }
          return tasks[selectedDate] || [];
        }, [tasks, selectedDate, showAllTasks]);
        const filteredAndSortedTasks = useMemo(() => {
          let currentTasks = [...tasksToDisplaySource];
          if (filter === "active")
            currentTasks = currentTasks.filter((task) => !task.completed);
          else if (filter === "completed")
            currentTasks = currentTasks.filter((task) => task.completed);
          if (categoryFilter !== "all")
            currentTasks = currentTasks.filter(
              (task) => task.category === categoryFilter
            );
          if (searchQuery) {
            const query = searchQuery.toLowerCase();
            currentTasks = currentTasks.filter(
              (task) =>
                task.title.toLowerCase().includes(query) ||
                (task.description &&
                  task.description.toLowerCase().includes(query))
            );
          }
          currentTasks.sort((a, b) => {
            if (sortBy === "time") {
              if (!a.time && !b.time) return 0;
              if (!a.time) return 1;
              if (!b.time) return -1;
              return a.time.localeCompare(b.time);
            } else if (sortBy === "priority") {
              const priorityOrder = { high: 1, medium: 2, low: 3, default: 4 };
              return (
                (priorityOrder[a.priority] || priorityOrder.default) -
                (priorityOrder[b.priority] || priorityOrder.default)
              );
            }
            if (showAllTasks && sortBy !== "originalDate") {
              if (a.originalDate < b.originalDate) return -1;
              if (a.originalDate > b.originalDate) return 1;
            }
            return 0;
          });
          return currentTasks;
        }, [
          tasksToDisplaySource,
          filter,
          sortBy,
          showAllTasks,
          categoryFilter,
          searchQuery,
        ]);
        const taskProgress = useMemo(() => {
          const totalTasks = tasksToDisplaySource.length;
          const completedTasks = tasksToDisplaySource.filter(
            (task) => task.completed
          ).length;
          return totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;
        }, [tasksToDisplaySource]);
        const handleAddTask = (taskDetails) => {
          const targetDate = taskDetails.date;
          if (!targetDate) {
            showAppNotification("Please select a date for the task.", "error");
            return;
          }
          const newTask = {
            id: Date.now(),
            ...taskDetails,
            completed: false,
            date: undefined,
          };
          setTasks((prevTasks) => ({
            ...prevTasks,
            [targetDate]: [...(prevTasks[targetDate] || []), newTask],
          }));
          showAppNotification("Task added successfully!", "success");
        };
        const handleToggleComplete = (taskId, taskDateKey) => {
          const dateKey = taskDateKey || selectedDate;
          let taskStatus = "";
          setTasks((prevTasks) => {
            const newDateTasks =
              prevTasks[dateKey]?.map((task) => {
                if (task.id === taskId) {
                  taskStatus = !task.completed
                    ? "completed"
                    : "marked as active";
                  return { ...task, completed: !task.completed };
                }
                return task;
              }) || [];
            return { ...prevTasks, [dateKey]: newDateTasks };
          });
          if (taskStatus) showAppNotification(`Task ${taskStatus}.`, "info");
          if (viewingTaskDetails && viewingTaskDetails.id === taskId) {
            setViewingTaskDetails((prev) => ({
              ...prev,
              completed: !prev.completed,
            }));
          }
        };
        const handleDeleteTask = (taskId, taskDateKey) => {
          if (
            window.confirm(
              "Are you sure you want to delete this task? This action cannot be undone."
            )
          ) {
            const dateKey = taskDateKey || selectedDate;
            setTasks((prevTasks) => ({
              ...prevTasks,
              [dateKey]:
                prevTasks[dateKey]?.filter((task) => task.id !== taskId) || [],
            }));
            if (editingTask?.id === taskId) setEditingTask(null);
            if (viewingTaskDetails?.id === taskId) setViewingTaskDetails(null);
            showAppNotification("Task deleted.", "info");
          }
        };
        const handleViewTaskDetails = (task) => {
          const taskWithDate = {
            ...task,
            displayDate: task.originalDate || selectedDate,
          };
          setViewingTaskDetails(taskWithDate);
        };
        const openEditModalFromDetail = (taskToEdit) => {
          setViewingTaskDetails(null);
          setEditingTask({
            ...taskToEdit,
            dateKeyForEdit:
              taskToEdit.displayDate || taskToEdit.originalDate || selectedDate,
          });
        };
        const handleEditTask = (updatedTask) => {
          const dateKey = updatedTask.dateKeyForEdit;
          const newDateKey = updatedTask.date || dateKey;
          if (!newDateKey) {
            console.error("Task date key for edit is missing!");
            setEditingTask(null);
            showAppNotification(
              "Error editing task: date key missing.",
              "error"
            );
            return;
          }
          setTasks((prevTasks) => {
            let updatedTasks = { ...prevTasks };
            if (dateKey !== newDateKey) {
              updatedTasks[dateKey] =
                prevTasks[dateKey]?.filter(
                  (task) => task.id !== updatedTask.id
                ) || [];
            }
            const taskToSave = {
              ...updatedTask,
              dateKeyForEdit: undefined,
              date: undefined,
            };
            updatedTasks[newDateKey] =
              prevTasks[newDateKey]?.map((task) =>
                task.id === updatedTask.id ? taskToSave : task
              ) || [];
            if (
              !updatedTasks[newDateKey].some(
                (task) => task.id === updatedTask.id
              )
            ) {
              updatedTasks[newDateKey].push(taskToSave);
            }
            return updatedTasks;
          });
          setEditingTask(null);
          showAppNotification("Task updated successfully!", "success");
        };
        const handleKeyDown = (e) => {
          if (
            e.key === "/" &&
            e.target.tagName !== "INPUT" &&
            e.target.tagName !== "TEXTAREA"
          ) {
            e.preventDefault();
            searchInputRef.current?.focus();
          }
        };
        useEffect(() => {
          document.addEventListener("keydown", handleKeyDown);
          return () => document.removeEventListener("keydown", handleKeyDown);
        }, []);
        const priorityClasses = {
          high: "bg-red-600 hover:bg-red-700",
          medium: "bg-orange-600 hover:bg-orange-700",
          low: "bg-green-600 hover:bg-green-700",
        };
        const taskBorderPriority = {
          high: "border-l-4 priority-high",
          medium: "border-l-4 priority-medium",
          low: "border-l-4 priority-low",
        };
        return (
          <ErrorBoundary>
            <div className="min-h-screen">
              <Notification
                key={notification.key}
                message={notification.message}
                type={notification.type}
                onClose={() =>
                  setNotification({ message: "", type: "", key: 0 })
                }
              />
              <div className="container mx-auto p-4 md:p-8 max-w-5xl">
                <header className="mb-6 md:mb-8">
                  <div className="flex justify-between items-center">
                    <div>
                      <h1 className="text-3xl sm:text-4xl md:text-5xl font-bold text-sky-400 tracking-tight">
                        Daily Planner
                      </h1>
                      <p className="text-slate-400 mt-1 text-sm sm:text-base">
                        {showAllTasks
                          ? "Viewing all tasks"
                          : `Organize for ${formatDateForDisplay(
                              selectedDate
                            )} `}
                      </p>
                    </div>
                    <div className="flex items-center space-x-2">
                      <input
                        ref={searchInputRef}
                        type="text"
                        value={searchQuery}
                        onChange={(e) => setSearchQuery(e.target.value)}
                        placeholder="Search tasks..."
                        className="bg-slate-700 border border-slate-600 text-slate-100 text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 block w-44 p-2.5 shadow-sm"
                        aria-label="Search tasks"
                      />
                      <ion-icon
                        name="search-outline"
                        className="text-slate-400 text-xl"
                      ></ion-icon>
                    </div>
                  </div>
                </header>
                <div className="bg-slate-800 shadow-2xl rounded-xl p-4 sm:p-6 md:p-8">
                  <div className="mb-6 flex flex-col sm:flex-row justify-between items-center gap-4">
                    <div
                      className={
                        showAllTasks ? "opacity-50 cursor-not-allowed" : ""
                      }
                    >
                      <label
                        htmlFor="date-picker-flatpickr"
                        className="block text-sm font-medium text-slate-300 mb-1"
                      >
                        Select Date:
                      </label>
                      <input
                        type="text"
                        id="date-picker-flatpickr"
                        ref={dateInputRef}
                        readOnly
                        disabled={showAllTasks}
                        className="bg-slate-700 border border-slate-600 text-slate-100 text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 block w-full p-2.5 shadow-sm disabled:opacity-70 disabled:cursor-not-allowed"
                        aria-label="Select date"
                      />
                    </div>
                    <div className="flex items-end gap-3 sm:gap-4 flex-wrap sm:ml-auto">
                      <button
                        onClick={() => {
                          setShowAllTasks((prev) => !prev);
                          if (showAllTasks)
                            setSelectedDate(getTodayDateString());
                        }}
                        className={`px-4 py-2.5 text-sm font-medium rounded-lg shadow-sm transition-colors ${
                          showAllTasks
                            ? "bg-sky-500 text-white"
                            : "bg-slate-600 text-slate-200 hover:bg-slate-500"
                        }`}
                        aria-pressed={showAllTasks}
                      >
                        {showAllTasks ? "View Selected Date" : "View All Tasks"}
                      </button>
                      <div>
                        <label
                          htmlFor="category-filter"
                          className="block text-sm font-medium text-slate-300 mb-1"
                        >
                          Category:
                        </label>
                        <select
                          id="category-filter"
                          value={categoryFilter}
                          onChange={(e) => setCategoryFilter(e.target.value)}
                          className="bg-slate-700 border border-slate-600 text-slate-100 text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 block w-full p-2.5 shadow-sm"
                          aria-label="Filter by category"
                        >
                          {categories.map((category) => (
                            <option key={category} value={category}>
                              {category.charAt(0).toUpperCase() +
                                category.slice(1)}
                            </option>
                          ))}
                        </select>
                      </div>
                      <div>
                        <label
                          htmlFor="filter"
                          className="block text-sm font-medium text-slate-300 mb-1"
                        >
                          Status:
                        </label>
                        <select
                          id="filter"
                          value={filter}
                          onChange={(e) => setFilter(e.target.value)}
                          className="bg-slate-700 border border-slate-600 text-slate-100 text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 block w-full p-2.5 shadow-sm"
                          aria-label="Filter by status"
                        >
                          <option value="all">All</option>
                          <option value="active">Active</option>
                          <option value="completed">Completed</option>
                        </select>
                      </div>
                      <div>
                        <label
                          htmlFor="sort"
                          className="block text-sm font-medium text-slate-300 mb-1"
                        >
                          Sort By:
                        </label>
                        <select
                          id="sort"
                          value={sortBy}
                          onChange={(e) => setSortBy(e.target.value)}
                          className="bg-slate-700 border border-slate-600 text-slate-100 text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 block w-full p-2.5 shadow-sm"
                          aria-label="Sort tasks"
                        >
                          <option value="time">Time</option>
                          <option value="priority">Priority</option>
                        </select>
                      </div>
                    </div>
                  </div>
                  <div className="mb-6">
                    <div className="flex justify-between items-center mb-2">
                      <h2 className="text-xl sm:text-2xl font-semibold text-sky-400">
                        {showAllTasks
                          ? "All Tasks"
                          : `Tasks for ${formatDateForDisplay(selectedDate)} `}
                      </h2>
                      <div className="text-sm text-slate-400">
                        {tasksToDisplaySource.length > 0 && (
                          <span>{Math.round(taskProgress)}% Complete</span>
                        )}
                      </div>
                    </div>
                    {tasksToDisplaySource.length > 0 && (
                      <div className="progress-bar">
                        <div
                          className="progress-bar-fill"
                          style={{ width: `${taskProgress}%` }}
                        ></div>
                      </div>
                    )}
                  </div>
                  <TaskForm
                    onAddTask={handleAddTask}
                    formId="addTaskForm"
                    selectedDateForNewTask={selectedDate}
                    showAppNotification={showAppNotification}
                  />
                  {filteredAndSortedTasks.length > 0 && (
                    <div className="space-y-4 mt-6 max-h-[55vh] overflow-y-auto pr-2">
                      {filteredAndSortedTasks.map((task) => (
                        <TaskItem
                          key={task.id}
                          task={task}
                          onToggleComplete={() =>
                            handleToggleComplete(
                              task.id,
                              task.originalDate || selectedDate
                            )
                          }
                          onViewDetails={() => handleViewTaskDetails(task)}
                          priorityClasses={priorityClasses}
                          taskBorderPriority={taskBorderPriority}
                          showDate={showAllTasks}
                        />
                      ))}
                    </div>
                  )}
                </div>
                <footer className="mt-6 text-center text-sm text-slate-400">
                  <p>
                    &copy; 2025{" "}
                    <a
                      href="mailto:barrtechsolutions@gmail.com"
                      className="text-sky-400 hover:text-sky-300 transition-colors"
                    >
                      BarrTech Solutions
                    </a>
                    . All rights reserved.
                  </p>
                </footer>
                {viewingTaskDetails && (
                  <TaskDetailModal
                    task={viewingTaskDetails}
                    onClose={() => setViewingTaskDetails(null)}
                    onEdit={() => openEditModalFromDetail(viewingTaskDetails)}
                    onDelete={() =>
                      handleDeleteTask(
                        viewingTaskDetails.id,
                        viewingTaskDetails.displayDate ||
                          viewingTaskDetails.originalDate ||
                          selectedDate
                      )
                    }
                    onToggleComplete={() =>
                      handleToggleComplete(
                        viewingTaskDetails.id,
                        viewingTaskDetails.displayDate ||
                          viewingTaskDetails.originalDate ||
                          selectedDate
                      )
                    }
                    showDate={showAllTasks || viewingTaskDetails.originalDate}
                    displayDate={
                      viewingTaskDetails.displayDate ||
                      viewingTaskDetails.originalDate
                    }
                  />
                )}
                {editingTask && (
                  <EditTaskModal
                    task={editingTask}
                    onSave={handleEditTask}
                    onClose={() => setEditingTask(null)}
                    showAppNotification={showAppNotification}
                  />
                )}
              </div>
            </div>
          </ErrorBoundary>
        );
      }
      function TaskForm({
        onAddTask,
        initialData = null,
        onSave,
        formId,
        showAppNotification,
        selectedDateForNewTask,
      }) {
        const [title, setTitle] = useState("");
        const [description, setDescription] = useState("");
        const [time, setTime] = useState("");
        const [priority, setPriority] = useState("medium");
        const [category, setCategory] = useState("");
        const [image, setImage] = useState(null);
        const [taskDate, setTaskDate] = useState(
          initialData?.dateKeyForEdit || selectedDateForNewTask || ""
        );
        const titleInputRef = useRef(null);
        const dateInputRef = useRef(null);
        const flatpickrInstanceRef = useRef(null);
        const imageInputId = `${formId}-image-input`;
        const dateInputId = `${formId}-date-input`;
        const isEditing = !!initialData;
        useEffect(() => {
          if (initialData) {
            setTitle(initialData.title || "");
            setDescription(initialData.description || "");
            setTime(initialData.time || "");
            setPriority(initialData.priority || "medium");
            setCategory(initialData.category || "");
            setImage(initialData.imageUrl || null);
            setTaskDate(
              initialData.dateKeyForEdit ||
                initialData.originalDate ||
                selectedDateForNewTask ||
                ""
            );
          } else {
            setTitle("");
            setDescription("");
            setTime("");
            setPriority("medium");
            setCategory("");
            setImage(null);
            setTaskDate(selectedDateForNewTask || "");
            const fileInput = document.getElementById(imageInputId);
            if (fileInput) fileInput.value = null;
          }
        }, [initialData, formId, selectedDateForNewTask]);
        useEffect(() => {
          if (dateInputRef.current) {
            if (flatpickrInstanceRef.current)
              flatpickrInstanceRef.current.destroy();
            const instance = flatpickr(dateInputRef.current, {
              dateFormat: "Y-m-d",
              defaultDate: taskDate || selectedDateForNewTask,
              disableMobile: true,
              allowInput: false,
              onChange: (selectedDatesArr) => {
                if (selectedDatesArr[0]) {
                  setTaskDate(selectedDatesArr[0].toISOString().split("T")[0]);
                }
              },
            });
            flatpickrInstanceRef.current = instance;
          }
          return () => {
            if (flatpickrInstanceRef.current) {
              flatpickrInstanceRef.current.destroy();
              flatpickrInstanceRef.current = null;
            }
          };
        }, [taskDate, selectedDateForNewTask]);
        const handleImageChange = (e) => {
          const file = e.target.files[0];
          if (file) {
            if (file.size > 5 * 1024 * 1024) {
              showAppNotification("Image size should not exceed 5MB.", "error");
              e.target.value = null;
              return;
            }
            const reader = new FileReader();
            reader.onloadend = () => setImage(reader.result);
            reader.readAsDataURL(file);
          }
        };
        const clearImage = () => {
          setImage(null);
          const fileInput = document.getElementById(imageInputId);
          if (fileInput) fileInput.value = null;
        };
        const handleSubmit = (e) => {
          e.preventDefault();
          if (!title.trim()) {
            showAppNotification("Task title cannot be empty.", "error");
            titleInputRef.current?.focus();
            return;
          }
          if (!taskDate) {
            showAppNotification("Please select a date for the task.", "error");
            dateInputRef.current?.focus();
            return;
          }
          const taskDetails = {
            title,
            description,
            time,
            priority,
            category,
            imageUrl: image,
            date: taskDate,
          };
          if (isEditing && onSave) onSave({ ...initialData, ...taskDetails });
          else if (!isEditing && onAddTask) {
            onAddTask(taskDetails);
            setTitle("");
            setDescription("");
            setTime("");
            setPriority("medium");
            setCategory("");
            setTaskDate(selectedDateForNewTask || "");
            clearImage();
            titleInputRef.current?.focus();
          }
        };
        const formActionText = isEditing ? "Edit Task" : "Add New Task";
        const buttonText = isEditing ? "Save Changes" : "Add Task";
        const canSubmit = isEditing || (title.trim() !== "" && taskDate !== "");
        return (
          <form
            onSubmit={handleSubmit}
            className="mb-6 p-4 bg-slate-700/50 rounded-lg shadow"
            aria-labelledby={`${formId}-title`}
          >
            <h3
              id={`${formId}-title`}
              className="text-lg font-medium text-sky-300 mb-4"
            >
              {formActionText}
            </h3>
            <div className="space-y-4">
              <div>
                <label
                  htmlFor={`${formId}-title`}
                  className="block text-sm font-medium text-slate-300 mb-1"
                >
                  Title <span className="text-red-400">*</span>
                </label>
                <input
                  ref={titleInputRef}
                  type="text"
                  id={`${formId}-title`}
                  value={title}
                  onChange={(e) => setTitle(e.target.value)}
                  placeholder="Enter task title"
                  className="bg-slate-600 border border-slate-500 text-slate-100 text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 block w-full p-2.5 shadow-sm"
                  required
                  aria-required="true"
                />
              </div>
              <div>
                <label
                  htmlFor={dateInputId}
                  className="block text-sm font-medium text-slate-300 mb-1"
                >
                  Date <span className="text-red-400">*</span>
                </label>
                <input
                  ref={dateInputRef}
                  type="text"
                  id={dateInputId}
                  value={taskDate}
                  readOnly
                  placeholder="Select task date"
                  className="bg-slate-600 border border-slate-500 text-slate-100 text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 block w-full p-2.5 shadow-sm"
                  required
                  aria-required="true"
                  aria-label="Select task date"
                />
              </div>
              <div>
                <label
                  htmlFor={`${formId}-description`}
                  className="block text-sm font-medium text-slate-300 mb-1"
                >
                  Description
                </label>
                <textarea
                  id={`${formId}-description`}
                  value={description}
                  onChange={(e) => setDescription(e.target.value)}
                  placeholder="Enter task description (optional)"
                  rows="3"
                  className="bg-slate-600 border border-slate-500 text-slate-100 text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 block w-full p-2.5 shadow-sm"
                ></textarea>
              </div>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <label
                    htmlFor={`${formId}-time`}
                    className="block text-sm font-medium text-slate-300 mb-1"
                  >
                    Time
                  </label>
                  <input
                    type="time"
                    id={`${formId}-time`}
                    value={time}
                    onChange={(e) => setTime(e.target.value)}
                    className="bg-slate-600 border border-slate-500 text-slate-100 text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 block w-full p-2.5 shadow-sm"
                  />
                </div>
                <div>
                  <label
                    htmlFor={`${formId}-priority`}
                    className="block text-sm font-medium text-slate-300 mb-1"
                  >
                    Priority
                  </label>
                  <select
                    id={`${formId}-priority`}
                    value={priority}
                    onChange={(e) => setPriority(e.target.value)}
                    className="bg-slate-600 border border-slate-500 text-slate-100 text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 block w-full p-2.5 shadow-sm"
                  >
                    <option value="low">Low</option>
                    <option value="medium">Medium</option>
                    <option value="high">High</option>
                  </select>
                </div>
              </div>
              <div>
                <label
                  htmlFor={`${formId}-category`}
                  className="block text-sm font-medium text-slate-300 mb-1"
                >
                  Category
                </label>
                <input
                  type="text"
                  id={`${formId}-category`}
                  value={category}
                  onChange={(e) => setCategory(e.target.value)}
                  placeholder="Enter category (e.g., Work, Personal)"
                  className="bg-slate-600 border border-slate-500 text-slate-100 text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 block w-full p-2.5 shadow-sm"
                />
              </div>
              <div>
                <label
                  htmlFor={imageInputId}
                  className="block text-sm font-medium text-slate-300 mb-1"
                >
                  Image (Max 5MB)
                </label>
                <input
                  type="file"
                  id={imageInputId}
                  accept="image/*"
                  onChange={handleImageChange}
                  className="block w-full text-sm text-slate-300 file:mr-4 file:py-2 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-sky-500 file:text-white hover:file:bg-sky-600 cursor-pointer"
                />
              </div>
              {image && (
                <div className="p-2 border border-slate-600 rounded-lg bg-slate-600/30">
                  <p className="text-xs text-slate-400 mb-1">Preview:</p>
                  <img
                    src={image}
                    alt="Preview"
                    className="max-h-32 w-auto rounded object-contain mb-2"
                  />
                  <button
                    type="button"
                    onClick={clearImage}
                    className="text-xs text-red-400 hover:text-red-300 bg-slate-700 px-2 py-1 rounded hover:bg-slate-600 transition-colors"
                  >
                    Remove
                  </button>
                </div>
              )}
              <div className="flex justify-end">
                <button
                  type="submit"
                  disabled={!canSubmit}
                  className={`w-full sm:w-auto justify-center text-white font-medium rounded-lg text-sm px-5 py-2.5 text-center shadow-md transition-colors ${
                    canSubmit
                      ? "bg-sky-600 hover:bg-sky-700 focus:ring-4 focus:outline-none focus:ring-sky-800"
                      : "bg-slate-500 cursor-not-allowed"
                  }`}
                >
                  {buttonText}
                </button>
              </div>
            </div>
          </form>
        );
      }
      function TaskItem({
        task,
        onToggleComplete,
        onViewDetails,
        priorityClasses,
        taskBorderPriority,
        showDate,
      }) {
        return (
          <div
            className={`p-3 sm:p-4 bg-slate-700/70 rounded-lg shadow-lg hover:shadow-xl transition-all duration-300 hover:bg-slate-700 cursor-pointer ${
              task.completed ? "opacity-60" : ""
            } ${
              taskBorderPriority[task.priority] || "border-l-4 border-slate-500"
            }`}
            role="button"
            tabIndex={0}
            onKeyDown={(e) => {
              if (e.key === "Enter" || e.key === " ") onViewDetails();
            }}
            aria-label={`View details for task: ${task.title}`}
          >
            <div className="flex items-start justify-between gap-3">
              <div
                className="flex items-start space-x-3 flex-grow min-w-0"
                onClick={onViewDetails}
              >
                <div
                  className="mt-1 shrink-0"
                  onClick={(e) => e.stopPropagation()}
                >
                  <input
                    type="checkbox"
                    checked={task.completed}
                    onChange={onToggleComplete}
                    className="form-checkbox h-5 w-5 text-sky-500 bg-slate-600 border-slate-500 rounded focus:ring-sky-400 focus:ring-offset-slate-800 cursor-pointer"
                    aria-label={`Mark task ${task.title} as ${
                      task.completed ? "incomplete" : "complete"
                    }`}
                  />
                </div>
                <div className="flex-grow">
                  <h3
                    className={`font-semibold text-lg break-words ${
                      task.completed
                        ? "line-through text-slate-400"
                        : "text-slate-100"
                    }`}
                  >
                    {task.title}
                  </h3>
                  {task.description && (
                    <p
                      className={`text-sm text-slate-300 mt-1 truncate ${
                        task.completed ? "line-through" : ""
                      }`}
                    >
                      {task.description}
                    </p>
                  )}
                  <div className="flex flex-wrap items-center gap-x-2 gap-y-1 text-xs text-slate-400 mt-2">
                    {task.time && (
                      <span>ðŸ•’ {formatTimeForDisplay(task.time)}</span>
                    )}
                    <span
                      className={`px-2 py-0.5 rounded-full text-xs font-semibold text-white ${
                        priorityClasses[task.priority] || "bg-slate-500"
                      }`}
                    >
                      {task.priority.charAt(0).toUpperCase() +
                        task.priority.slice(1)}
                    </span>
                    {task.category && (
                      <span className="px-2 py-0.5 rounded-full bg-purple-600 text-white">
                        {task.category}
                      </span>
                    )}
                    {showDate && task.originalDate && (
                      <span className="px-2 py-0.5 rounded-full bg-slate-600 text-slate-300">
                        ðŸ“… {formatShortDate(task.originalDate)}
                      </span>
                    )}
                  </div>
                </div>
              </div>
            </div>
          </div>
        );
      }
      function TaskDetailModal({
        task,
        onClose,
        onEdit,
        onDelete,
        onToggleComplete,
        showDate,
        displayDate,
      }) {
        if (!task) return null;
        const taskDate = displayDate || task.originalDate;
        return (
          <div
            className="modal-overlay"
            role="dialog"
            aria-labelledby="modal-title"
            aria-modal="true"
          >
            <div className="modal-content bg-slate-800 text-slate-100 shadow-2xl rounded-lg">
              <button
                onClick={onClose}
                className="modal-close-button text-slate-400 hover:text-slate-200"
                aria-label="Close modal"
              >
                <ion-icon name="close-outline"></ion-icon>
              </button>
              <h2
                id="modal-title"
                className="text-2xl font-bold text-sky-400 mb-1"
              >
                {task.title}
              </h2>
              <div className="text-xs text-slate-400 mb-4">
                {taskDate && <span>ðŸ“… {formatDateForDisplay(taskDate)}</span>}
                {task.time && (
                  <span className="ml-2">
                    ðŸ•’ {formatTimeForDisplay(task.time)}
                  </span>
                )}
              </div>
              {task.description && (
                <div className="mb-4">
                  <h4 className="text-sm font-semibold text-slate-300 mb-1">
                    Description:
                  </h4>
                  <p className="task-description-content text-slate-200">
                    {task.description}
                  </p>
                </div>
              )}
              <div className="mb-4">
                <h4 className="text-sm font-semibold text-slate-300 mb-1">
                  Priority:
                </h4>
                <span
                  className={`px-3 py-1 rounded-full text-sm font-semibold text-white ${
                    task.priority === "high"
                      ? "bg-red-600"
                      : task.priority === "medium"
                      ? "bg-orange-600"
                      : "bg-green-600"
                  }`}
                >
                  {task.priority.charAt(0).toUpperCase() +
                    task.priority.slice(1)}
                </span>
              </div>
              {task.category && (
                <div className="mb-4">
                  <h4 className="text-sm font-semibold text-slate-300 mb-1">
                    Category:
                  </h4>
                  <span className="px-3 py-1 rounded-full text-sm font-semibold text-white bg-purple-600">
                    {task.category}
                  </span>
                </div>
              )}
              {task.imageUrl && (
                <div className="mb-4">
                  <h4 className="text-sm font-semibold text-slate-300 mb-1">
                    Attached Image:
                  </h4>
                  <img
                    src={task.imageUrl}
                    alt="Task image"
                    className="max-h-60 w-auto rounded-md object-contain shadow-lg border border-slate-700"
                  />
                </div>
              )}
              <div className="mt-6 pt-4 border-t border-slate-700 flex flex-col sm:flex-row justify-end space-y-2 sm:space-y-0 sm:space-x-3">
                <button
                  onClick={onToggleComplete}
                  className={`w-full sm:w-auto px-4 py-2 rounded-md font-medium transition-colors ${
                    task.completed
                      ? "bg-yellow-500 hover:bg-yellow-600 text-slate-900"
                      : "bg-emerald-500 hover:bg-emerald-600 text-white"
                  }`}
                >
                  {task.completed ? "Mark as Incomplete" : "Mark as Complete"}
                </button>
                <button
                  onClick={onEdit}
                  className="w-full sm:w-auto px-4 py-2 bg-sky-600 hover:bg-sky-700 text-white rounded-md font-medium transition-colors"
                >
                  Edit
                </button>
                <button
                  onClick={onDelete}
                  className="w-full sm:w-auto px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-md font-medium transition-colors"
                >
                  Delete
                </button>
              </div>
            </div>
          </div>
        );
      }
      function EditTaskModal({ task, onSave, onClose, showAppNotification }) {
        const modalFormId = `editTaskForm-${task.id}`;
        return (
          <div
            className="modal-overlay"
            role="dialog"
            aria-labelledby={`${modalFormId}-title`}
            aria-modal="true"
          >
            <div className="modal-content bg-slate-800 text-slate-100 shadow-2xl rounded-lg w-full">
              <button
                onClick={onClose}
                className="modal-close-button text-slate-400 hover:text-slate-200"
                aria-label="Close modal"
              >
                <ion-icon name="close-outline"></ion-icon>
              </button>
              <TaskForm
                initialData={task}
                onSave={onSave}
                formId={modalFormId}
                showAppNotification={showAppNotification}
                selectedDateForNewTask={task.dateKeyForEdit}
              />
            </div>
          </div>
        );
      }
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
    <script>
      (function () {
        function c(a) {
          var b = a.contentDocument || a.contentWindow.document;
          if (b) {
            var d = b.createElement("script");
            d.innerHTML =
              "window.__CF$cv$params={r:'93eaf4270cd5507e',t:'MTc0NzA2Mzc4OC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";
            b.getElementsByTagName("head")[0].appendChild(d);
          }
        }
        if (document.body) {
          var a = document.createElement("iframe");
          a.height = 1;
          a.width = 1;
          a.style.position = "absolute";
          a.style.top = 0;
          a.style.left = 0;
          a.style.border = "none";
          a.style.visibility = "hidden";
          document.body.appendChild(a);
          if ("loading" !== document.readyState) c();
          else if (window.addEventListener)
            document.addEventListener("DOMContentLoaded", c);
          else {
            var e = document.onreadystatechange || function () {};
            document.onreadystatechange = function (b) {
              e(b);
              if ("loading" !== document.readyState) {
                document.onreadystatechange = e;
                c();
              }
            };
          }
        }
      })();
    </script>
    <script>
      (function () {
        function c(a) {
          var b = a.contentDocument || a.contentWindow.document;
          if (b) {
            var d = b.createElement("script");
            d.innerHTML =
              "window.__CF$cv$params={r:'93eb396b7a55c015',t:'MTc0NzA2NjYyNS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";
            b.getElementsByTagName("head")[0].appendChild(d);
          }
        }
        if (document.body) {
          var a = document.createElement("iframe");
          a.height = 1;
          a.width = 1;
          a.style.position = "absolute";
          a.style.top = 0;
          a.style.left = 0;
          a.style.border = "none";
          a.style.visibility = "hidden";
          document.body.appendChild(a);
          if ("loading" !== document.readyState) c();
          else if (window.addEventListener)
            document.addEventListener("DOMContentLoaded", c);
          else {
            var e = document.onreadystatechange || function () {};
            document.onreadystatechange = function (b) {
              e(b);
              "loading" !== document.readyState &&
                ((document.onreadystatechange = e), c());
            };
          }
        }
      })();
    </script>
  </body>
</html>
